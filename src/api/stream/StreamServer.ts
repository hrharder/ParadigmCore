/**
 * ===========================
 * ParadigmCore: Blind Star
 * @name StreamServer.ts
 * @module api/stream
 * ===========================
 *
 * @author Henry Harder
 * @date (initial)  05-February-2019
 * @date (modified) 13-March-2019
**/

// request/response objects
import { Request as Req } from "./Request";
import { Response as Res } from "./Response";

// common imports
import { err, log, warn } from "../../common/log";
import { TendermintRPC } from "../../common/TendermintRPC.js";
import { convertIsoTimeToUnixMs } from "../../common/utils";
import { decodeTx } from "../../core/util/utils";

// stream server utils
import {createResponse, createValError, parseOrdersForSubscription } from "./utils.js";

// third party/std-lib
import { createHash, Hash } from "crypto";
import { EventEmitter } from "events";
import * as _ from "lodash";
import * as WebSocket from "ws";

/**
 * Defines the object provided to the `StreamServer` constructor.
 */
interface IOptions {
    /** URL of the local Tendermint RPC server. */
    tendermintRpcUrl?: string;

    /** Interval between connection attempts (in ms). */
    retryInterval?: number;

    /** The maximum number of times to retry connection before throwing. */
    retryMax?: number;

    /** Port to bind the StreamAPI server to. */
    port?: number;

    /** Network host to bind StreamAPI server. */
    host?: string;

    /** Optional pre-defined method implementations. */
    methods?: {
        [name: string]: (server: StreamServer, client: WebSocket, params: any) => any;
    };
}

/**
 * Defines the parsed block data from the tendermint `NewBlock` event.
 *
 * @todo move to `typings` module
 */
interface IBlockData {
    /**
     * The best known tendermint block (height).
     */
    height?: number;

    /**
     * The unix timestamp of the time the block was committed.
     */
    time?: number;

    /**
     * An array of stringified (yet parsed) transaction objects
     */
    txs?: string[];
}

/**
 * Raw block data as delivered over Tendermint JSONRPC (pre-parsing).
 */
interface RawBlockData {
    block: {
        header: {
            version: {
                block: string;
                app: string;
            },
            chain_id: string;
            height: string;
            time: string;
            num_txs: string;
            total_txs: string;
            last_commit_hash: string;
            validators_hash: string;
            app_hash: string;
            last_block_id: {
                hash: string;
            }
        },
        data: {
            txs: any[];
        }
    };
}

/**
 * Defines the subscription-tracking object.
 */
interface ISubscriptions {
    [id: string]: ISubscription;
}

/**
 * Defines the object type used to represent an event subscription.
 */
interface ISubscription {
    subscriptionId: string;
    clientId: string;
    connection: WebSocket;
    params: {
        eventName: string;
        filters?: string[];
    };
}

/**
 * Defines the ConnectionMap interface.
 *
 * @todo expand to point to subscriptions, and track other data
 */
interface IConnectionMap {
    [connectionId: string]: WebSocket;
}

/**
 * Mapping of methods to method implementations.
 *
 * The `this` arg for the active [[StreamServer]] instance is passed into all
 * bound methods, so they may access instance data, such as the current block
 * info, etc.
 *
 * @todo examine if a better structure is needed
 */
interface IMethods {
    [methodName: string]: (server: StreamServer, client: WebSocket, params: any) => any;
}

/**
 * The `StreamServer` class is a TypeScript implementation of the StreamAPI,
 * intended to be used with JSONRPC(2.0)/WebSocket.
 *
 * Certain endpoints may be
 * implemented with an HTTP server to support JSONRPC(2.0)/POST for things like
 * submitting an order transaction via RPC.
 */
export class StreamServer extends EventEmitter {

    /**
     * Generate a pseudo-random byte array
     *
     * @description This static method returns a pseudo-random 32 byte SHA256
     * hash used for various security mechanisms within the class. Generated by
     * concatenating 16 random bytes from memory, plus the raw bytes of the
     * string characters that represent the current unix timestamp (in ms),
     * and digesting the 32 byte SHA256 hash of the result.
     *
     * Highly non-deterministic; each call will produce different output.
     *
     * @param start if provided, indicates from which byte (0-indexed) to slice
     */
    private static generate32RandomBytes(start?: number): Buffer {
        // hash engine and output buffer
        let output: Buffer;
        const hash: Hash = createHash("sha256");

        // generate byes of timestamp string
        const timestampString: string = Date.now().toString();
        const timestampBytes = Buffer.from(timestampString, "utf8");

        // grab 16 byes from memory (unsafe-ish, shouldn't leave function scope)
        const unsafeBytes: Buffer = Buffer.allocUnsafe(16);

        // update hash with bytes from timestamp and memory
        hash.update(timestampBytes);
        hash.update(unsafeBytes);

        // digest hash and store output buffer
        output = hash.digest();

        // return full or part output bytes
        return start ? output.slice(start) : output;
    }

    /**
     * Generate client-safe `eventId` from secret connectionId
     *
     * @description The `subscription.eventId` (used to track individual event
     * subscriptions) is the first 16 bytes of the SHA256 hash of connectionId,
     * with 16 bytes of salt, as a hex encoded string.
     *
     * Assume to be deterministic (given same input/salt).
     *
     * @param connectionId a 32 byte
     */
    private static generateEventId(connectionId: string, salt: Buffer): string {
        const hash: Hash = createHash("sha256");
        const connectionIdBytes: Buffer = Buffer.from(connectionId, "hex");

        // update hash with id bytes and salt
        hash.update(connectionIdBytes);
        hash.update(salt);

        // convert to hex string and slice first bytes
        const output: Buffer = hash.digest().slice(0, 16);
        const eventId: string = output.toString("hex");
        return eventId;
    }

    /**
     * Generate secret `connectionId`
     *
     * @description Every connected client has a secret `connectionId` generated
     * from the server's `secret` and some salt. The `connectionId` string is a
     * hex-string of the hash of the server's `secret` salted with an arbitrary
     * number of "random" bytes.
     *
     * Assume to be deterministic (given same input/salt).
     *
     * @param secret the server's `secret` 32 bytes
     * @param salt an arbitrary number of random-ish bytes to be used as salt
     */
    private static generateConnectionId(secret: Buffer, salt: Buffer): string {
        const hash: Hash = createHash("sha256");

        // update hash with secret and salt
        hash.update(secret);
        hash.update(salt);

        // digest hash and convert output bytes to hex string
        const output: Buffer = hash.digest().slice(0, 32);
        const connectionId: string = output.toString("hex");
        return connectionId;
    }

    /**
     * Server secret bytes
     *
     * A pseudo-random 32 byte `Buffer` used (along with the UNIX time) as salt
     * when hashing client-provided `request.id` strings. Should not be shared
     * with the client (as a precaution).
     */
    private secret: Buffer;

    /**
     * Mapping of method handler functions.
     */
    private methods: IMethods;

    /**
     * Tendermint RPC client instance.
     *
     * @description Instance of `TendermintRPC`, the custom wrapper used to
     * interact with Tendermint and the ParadigmCore chain via the local
     * Tendermint RPC server. See [[TendermintRPC]] documentation for more info.
     */
    private rpcClient: TendermintRPC;

    /**
     * Data for the latest Tendermint block.
     *
     * @description The most recent (parsed) block-data from the Tendermint RPC
     * server, not including transactions.
     */
    private latestBlockData: IBlockData;

    /**
     * Number of times to attempt RPC connection.
     *
     * @description Used to facilitate reestablishment of WebSocket connection
     * upon error or unexpected closure.
     */
    private retryMax: number;

    /**
     * Interval (in ms) between retry attempts
     *
     * @description The millisecond interval between attempts to reconnect to
     * the Tendermint RPC server. Used by the [[TendermintRPC]] class.
     */
    private retryInterval: number;

    /**
     * StreamAPI port
     *
     * @description The port to expose the StreamAPI WebSocket server on.
     */
    private streamPort: number;

    /**
     * Stream host
     *
     * @description The network host to bind the StreamAPI server to.
     */
    private streamHost: string;

    /**
     * StreamAPI WebSocket server instance
     *
     * @description The actual `ws.Server` instance used to handle requests.
     * Not to be confused with the `StreamServer` class, which is the actual
     * implementation of the JSONRPC spec for transport over WebSocket.
     */
    private server: WebSocket.Server;

    /**
     * Mapping of subscription objects (by subscriptionId)
     *
     * @description Master array of active subscriptions, where each entry has a
     * `subscription.connectionId` which is the the utf8 hex-string of the first
     * 8 bytes of the hash of the client-provided `request.id` concatenated with
     * the fist 16 bytes of a random byte array (which includes a time-hash).
     * The `connectionId` maps to an actual WebSocket connection object, and
     * should be kept private from clients;
     *
     * The `subscription.eventId` (used to track individual event subscriptions)
     * is a random `uuid/v4` string.
     *
     * ```ts
     * connectionId = StreamServer.generateSecretBytes();
     * eventId = StreamServer.genEventIdFromConnId(connectionId);
     * ```
     */
    private subscriptions: ISubscriptions;

    /**
     * Mapping of active `connectionId` strings to connection objects
     *
     * @description Used to quickly find a connection object pointer (to an
     * instance of[[WebSocket]]), used to send messages, etc.
     */
    private connectionMap: IConnectionMap;

    /**
     * Server status
     *
     * @description Only true if `StreamServer.prototype.start()` has executed
     * and the promise has resolved/not been rejected.
     */
    private started: boolean;
    /**
     * Create a new `StreamServer` instance.
     *
     * @description more docs coming soon.
     *
     * @param options see [[IOptions]] interface definition
     */
    constructor(options: IOptions = {}) {
        // inherit this from EventEmitter
        super();

        // generate server secret (used for the duration of the process)
        this.secret = StreamServer.generate32RandomBytes();

        // setup subscription and connection tracking objects
        this.subscriptions = {};
        this.connectionMap = {};

        // setup methods object
        this.methods = {};

        // setup block data tracker
        this.latestBlockData = {};

        // server config
        this.streamPort = options.port || 14342;
        this.streamHost = options.host || "localhost";

        // set params for Tendermint RPC connection
        this.retryMax = options.retryMax || 30;
        this.retryInterval = options.retryInterval || 2000;

        // tendermint rpc connection
        this.rpcClient = new TendermintRPC(
            options.tendermintRpcUrl,
            this.retryMax,
            this.retryInterval,
        );

        // if pre-defined methods provided, bind each
        if (options.methods) {
            this.bindMethods(options.methods);
        }

        // set initial status
        this.started = false;
        return;
    }

    // BEGIN public methods

    /**
     * Start the StreamAPI server.
     *
     * An async function that binds the WebSocket server, and connects to the
     * local TendermintRPC instance.
     */
    public async start(): Promise<void> {
        // setup handler for successful tendermint connection
        this.rpcClient.on("open", this.createTendermintHandler());

        // connect to tendermint rpc server
        await this.rpcClient.connect(this.retryMax, this.retryInterval);

        // start listening to client requests
        this.setupServer(this.streamHost, this.streamPort);

        // attach handler for subscriptions
        this.on("newBlock", this.subscriptionTrigger);

        // set started status
        this.started = true;
        return;
    }

    /**
     * Bind a method to the StreamServer.
     *
     * @param methodName the name of the method to bind to
     * @param method the function object of the method implementation, using the correct call signature
     */
    public bind(
        methodName: string,
        method: (server: StreamServer, client: WebSocket, params: any) => any
    ): void {
        this.methods[methodName] = method;
    }

    /**
     * (In progress)
     *
     * This method is a public method to allow bound definitions to interact
     * with the private `subscriptions` mapping.
     */
    public addSubscription(
        subscriptionId: string,
        clientId: string,
        connection: WebSocket,
        params: any
    ): void {
        // create new subscription object
        const subscription: ISubscription = {
            connection,
            subscriptionId,
            clientId,
            params,
        };

        // add to mapping
        this.subscriptions[subscriptionId] = subscription;
    }

    /**
     * Remove a subscription (by `subscriptionId`).
     *
     * This method is a public method to allow bound definitions to interact
     * with the private `subscriptions` mapping.
     *
     * @todo: add check to ensure only the client that started a subscription can end it
     */
    public removeSubscription(subscriptionId: string): boolean {
        // check if subscriptionId exists at all
        const exists = this.subscriptions[subscriptionId] ? true : false;

        // attempt to remove subscription
        delete this.subscriptions[subscriptionId];

        // return `true` if valid, otherwise false
        return exists;
    }

    /**
     * Public function that returns latest known (most recent commit) block height.
     */
    public getLatestHeight(): number {
        return this.latestBlockData.height;
    }

    /**
     * Public function to execute state query over a provided path.
     *
     * @param path the string path to be passed to the ABCI query method
     */
    public async executeTendermintQuery(path: string): Promise<any> {
        return await this.rpcClient.query(path);
    }

    // END public methods

    // BEGIN private methods

    /**
     * Bind an object of pre-defined methods to the server.
     *
     * Used to optionally bind an object with pre-defined methods supplied to the
     * StreamServer's constructor.
     *
     * @param methods a user-provided object with pre-defined method implementations
     */
    private bindMethods(methods: IMethods): void {
        Object.keys(methods).forEach((method) => {
            this.bind(method, methods[method]);
        });
    }

    /**
     * Subscription trigger (documentation coming soon)
     */
    private subscriptionTrigger(): void {
        Object.keys(this.subscriptions).forEach((subId) => {
            // load subscription object, and client/sub ID's
            const sub = this.subscriptions[subId];
            const { clientId, subscriptionId } = sub;

            // create `CLIENT_ID/SUB_ID` string
            const id = `${clientId}/${subscriptionId}`;

            // load params for subscription
            const { eventName, filters } = sub.params;
            const { height, txs, time } = this.latestBlockData;

            // will be the message sent to client, and resulting block data
            let msg: Res;
            let result: any | IBlockData;

            // load full block data
            const fullResult = { height, txs, time };

            // filter, if filters are provided
            if (eventName === "block" && filters && !_.isEmpty(filters)) {
                result = Object.keys(fullResult).filter((key) => {
                    return filters.includes(key);
                }).reduce((obj, key) => {
                    obj[key] = fullResult[key];
                    return obj;
                }, {});
            } else if (eventName === "orders") {
                result = parseOrdersForSubscription(txs);
            } else {
                result = fullResult;
            }

            // create message object
            msg = createResponse(result, id);

            // deliver to subscribed connection
            this.sendMessageToConn(sub.connection, msg);
        });
    }

    /**
     * Creates a handler function for the TendermintRPC connection.
     *
     * Currently only subscribes to the Tendermint `NewBlock` event, but in the
     * future may be used to subscribe to additional tags and blockchain events,
     * used to notify clients an update the server's state.
     */
    private createTendermintHandler(): () => void {
        return () => {
            log("api", "connected to tendermint rpc server");

            // handle each new block
            this.rpcClient.subscribe("tm.event='NewBlock'", this.createNewBlockHandler());
            return;
        };
    }

    /**
     * Creates a handler function for Tendermint `NewBlock` events.
     *
     * Currently used to update the in-memory tracking of the current Tendermint
     * blockchain height. In the future may be used to pull additional block data
     * to be stored in-memory.
     */
    private createNewBlockHandler(): (data: RawBlockData) => void {
        return (data: RawBlockData) => {
            // update latest height
            const { height, time } = data.block.header;
            const { txs } = data.block.data;

            // parse time into unix time
            const unixTs = convertIsoTimeToUnixMs(time);

            // reset latest txs array
            this.latestBlockData.txs = [];

            // if there are any txs, parse, stringify, and store in-memory
            if (txs) {
                txs.forEach((i) => {
                    const txBuff = Buffer.from(i, "base64");
                    const tx = decodeTx(txBuff);
                    const txStr = JSON.stringify(tx); // .replace(/"/g, "'");
                    this.latestBlockData.txs.push(txStr);
                });
            }

            this.latestBlockData.height = parseInt(height, 10);
            this.latestBlockData.time = unixTs;

            // emit local `newBlock` event
            this.emit("newBlock");
            return;
        };
    }

    /**
     * Setup the StreamAPI WebSocket server
     *
     * @description Configure and start the StreamAPI JSONRPC(2.0) WebSocket
     * server, on the provided host and port.
     *
     * @param host network host to bind server to
     * @param port network port to bind server to
     */
    private setupServer(host: string, port: number): void {
        // set options and initialize
        const options = { host, port };
        this.server = new WebSocket.Server(options);

        // attach new connection handler
        this.server.on("connection", this.createConnectionHandler());

        // attach server error handler
        this.server.on("error", this.createErrorHandler());
        return;
    }

    /**
     * Creates an error handler for server errors.
     *
     * A generic method used to create an async (event) error handler. Currently
     * only used to handler server (not client<>server) errors, but in the future
     * may also handle additional errors.
     */
    private createErrorHandler(): (error: Error) => void {
        return (error: Error) => {
            // create error message string (to log AND emit)
            const message = `Internal Error: ${error.message}`;

            // log and emit error message;
            err("api", message);
            // this.emit("error", message);
            return;
        };
    }

    /**
     * Create a server connection handler.
     *
     * This method is used to create a handler function for connected clients.
     * It establishes the correct handler functions for connection events, and
     * binds method definitions to the connection object to handle JSONRPC
     * requests.
     *
     * @todo document better
     */
    private createConnectionHandler(): (connection: WebSocket) => void {
        return (connection: WebSocket) => {
            // generate a unique id string for this connection
            const connectionId = StreamServer.generateConnectionId(
                this.secret,
                StreamServer.generate32RandomBytes()
            );

            // store connection in mapping
            this.connectionMap[connectionId] = connection;

            // setup close/error handler to terminate connection tracking
            connection.on("close", this.createConnCloseHandler(connectionId));

            // handle incoming messages from connected clients
            connection.on("message", this.createConnMessageHandler(connectionId));

            // open connection handler
            connection.on("open", this.createConnOpenHandler(connectionId));

            // client connection error handler
            connection.on("error", this.createConnErrorHandler(connectionId));
            return;
        };
    }

    /**
     * Create an close event handler.
     *
     * This wrapper method builds a function to handle "close" events from the
     * connected clients. Currently, it will remove the client-tracking object
     * for the connection the disconnect event is received over.
     *
     * @param connId the server-side id string used to identify the connection
     */
    private createConnCloseHandler(connId: string): () => void {
        return () => {
            log("api", `Disconnect from connection "id": "${connId}"`);
            delete this.connectionMap[connId];
            return;
        };
    }

    /**
     * Create an open event handler.
     *
     * This wrapper method builds a function to handle "open" events from the
     * connected clients. Currently it is just used to log new connections,
     * but in the future may handle additional processing of new connections.
     *
     * @param connId the server-side id string used to identify the connection
     */
    private createConnOpenHandler(connId: string): () => void {
        return () => {
            log("api", `Got new connection with "id": "${connId}"`);
            return;
        };
    }

    /**
     * Create a client error handler.
     *
     * This wrapper function creates an error-handler function that handles any
     * internal server errors that occur during the client<>server connection,
     * or processing of client requests.
     *
     * @param connId the unique server-side id string used to identify the connection
     */
    private createConnErrorHandler(connId: string): (error: Error) => void {
        return (error: Error) => {
            // create error message object
            const intError = createValError(-32603, `Internal error: ${error.message}`);
            const res = createResponse(null, null, intError);

            // send error message to client
            warn("api", "Sending error message (internal) to client.");
            this.sendMessageToClient(connId, res);
            return;
        };
    }

    /**
     * Send a message to a connected client (by server id)
     *
     * Send a JSON response to a client identified by server-side connectionId.
     *
     * @param id the server-side client ID string
     * @param res a JsonResponse object
     */
    private sendMessageToClient(id: string, res: Res | Res[]) {
        // @todo make sure to properly handle disconnects
        const conn = this.connectionMap[id];
        if (!conn) { return; }
        if (conn.readyState !== conn.OPEN) { return; }
        conn.send(JSON.stringify(res));
        return;
    }

    /**
     * Send a message to a connected client (by conn. instance)
     *
     * Send a JSON response to a client to a specified connected client instance.
     *
     * @param conn the instance of the websocket client connection
     * @param res a JsonResponse object to be sent
     */
    private sendMessageToConn(conn: WebSocket, res: Res) {
        // @todo make sure to properly handle disconnects
        if (!conn) { return; }
        if (conn.readyState !== conn.OPEN) { return; }
        conn.send(JSON.stringify(res));
        return;
    }

    /**
     * Build a message handler function for a client.
     *
     * This method builds a function to handle incoming messages (requests) from
     * connected clients. It is used to delegate the processing of requests via
     * bound method definitions, that are attached with the `bind` method,
     * or passed into the constructor.
     *
     * @param connId the connectionId of the client the handler is for
     */
    private createConnMessageHandler(connId: string): (d: WebSocket.Data) => void {
        return async (msg: WebSocket.Data) => {
            // TEMPORARY
            log("api", `Message from connection '${connId}': '${msg}'`);

            // scope eventual response/request objects
            let res: Res, req: Req, error: ValidationError;

            // create request object and validate
            req = new Req(msg);
            error = req.validate();

            if (error && error.code === -32600) {
                const batchRes = await this.handleBatchRequest(msg, connId);
                this.sendMessageToClient(connId, batchRes);
                return;
            }

            // terminate execution on validation error
            if (error) {
                res = createResponse(null, null, error);
                this.sendMessageToClient(connId, res);
                return;
            }

            // if this point is reached, we will handle the request (or fail)
            const { params, id, method } = req.parsed;

            // handle bad method requests
            if (!this.methods[method]) {
                const methError = createValError(-32601, "method not implemented.");
                res = createResponse(null, null, methError);
                this.sendMessageToClient(connId, res);
                return;
            }

            // defer to bound method for execution
            res = await this.methods[method](this, this.connectionMap[connId], req);
            // res = createResponse(result, id, null);
            this.sendMessageToClient(connId, res);
            return;
        };
    }

    private async handleBatchRequest(msg: WebSocket.Data, connId: string): Promise<Res[] | Res> {
        let wasFailure = false;
        let responses: Res[] = [];
        let requests: Req[] = [];
        try {
            const parsed = JSON.parse(msg.toString());
            if (!_.isArray(parsed)) { return []; }

            // parse each request
            parsed.forEach((unknownRequest) => {
                const reqStr = JSON.stringify(unknownRequest);
                const req = new Req(reqStr);
                const error = req.validate();
                if (error) {
                    wasFailure = true;
                } else {
                    requests.push(req);
                }
            });
        } catch (err) {
            wasFailure = true;
        }

        for (let req of requests) {
            let res: Res;
            const { method } = req.parsed;
            try {
                res = await this.methods[method](this, this.connectionMap[connId], req);
            } catch (err) {
                wasFailure = true;
            }
            responses.push(res);
        }

        if (responses.length === 0) {
            wasFailure = true;
        }

        if (wasFailure) {
            const valErr = createValError(-32700, "error handling batch request");
            return createResponse(null, null, valErr);
        } else {
            return responses;
        }
    }
}
